/* autogenerated by Processing revision 1293 on 2024-01-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class normal_functions_using_lines extends PApplet {



PeasyCam cam;
ArrayList<ArrayList<PVector>> image;
ArrayList<ArrayList<PVector>> grid = new ArrayList<ArrayList<PVector>>();
FloatList colorList = new FloatList();
ArrayList<ArrayList<ArrayList<PVector>>> animation;

int status = 0;
int xedge,yedge;
int divideConst = 200;
int stepSize = 10;
int circleSize = 5;
int no_of_Frames = 360;
int currentFrame = 0;

int GRID_DISPLAY = 0;
int IMG_DISPLAY = 1;
int ANIMATION_DISPLAY = 2;
int REVERSE_ANIMATION_DISPLAY = 3;

public void setup() {
  /* size commented out by preprocessor */;
  colorMode(HSB);
  background(0);

  cam = new PeasyCam(this, 500);
  
  xedge = width/2 - 50;
  yedge = height/2 - 50;
  
  for (int i = -xedge; i < xedge; i = i + stepSize) {
    ArrayList<PVector> col = new ArrayList<PVector>();
    for (int j = -yedge; j < yedge; j = j + stepSize) {
      col.add(new PVector(PApplet.parseFloat(i), PApplet.parseFloat(j)));     // add + 0.000001 to avoid 1/r error (map function) 
    }
    grid.add(col);
  }
  image = mapping(grid);
  animation = generateFrame(grid, image);
 
}

public void draw() {
  background(0);
  strokeWeight(2);
  noFill();
  if (status == GRID_DISPLAY) {
    for(ArrayList<PVector> column:grid){
      float col = map(column.get(0).x,-xedge,xedge,0,255);
      colorList.append(col);
      stroke(col, 255, 255);
      beginShape();
      for(PVector v:column){
        vertex(v.x, v.y);
      }
      endShape();
    }

    for (int i = 0; i < grid.get(0).size(); ++i) {
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < grid.size(); ++j) {
        PVector v = grid.get(j).get(i);
        vertex(v.x, v.y);
      }
      endShape();
    }
  } else if (status == IMG_DISPLAY) {
    for (int i = 0; i < image.size(); ++i) {
      ArrayList<PVector> column = image.get(i);
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for(PVector v:column){
        vertex(v.x, v.y);
      }
      endShape();
    }
    for (int i = 0; i < image.get(0).size(); ++i) {
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < image.size(); ++j) {
        PVector v = image.get(j).get(i);
        vertex(v.x, v.y);
      }
      endShape();
    }
  } else if (status == ANIMATION_DISPLAY){
    for (int i = 0; i < animation.size(); ++i) {
      ArrayList<ArrayList<PVector>> column = animation.get(i);
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < column.size(); ++j) {
        ArrayList<PVector> list = column.get(j);
        PVector v = list.get(currentFrame);
        vertex(v.x, v.y);
      }
      endShape();
    }
    for (int i = 0; i < animation.get(0).size(); ++i) {
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < animation.size(); ++j) {
        PVector v = animation.get(j).get(i).get(currentFrame);
        vertex(v.x, v.y);
      }
      endShape();
    }
    currentFrame++;
    if (currentFrame == no_of_Frames-1) {
      status = IMG_DISPLAY;
    }
  } else if (status == REVERSE_ANIMATION_DISPLAY){
    for (int i = 0; i < animation.size(); ++i) {
      ArrayList<ArrayList<PVector>> column = animation.get(i);
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < column.size(); ++j) {
        ArrayList<PVector> list = column.get(j);
        PVector v = list.get(currentFrame);
        vertex(v.x, v.y);
      }
      endShape();
    }
    for (int i = 0; i < animation.get(0).size(); ++i) {
      stroke(colorList.get(i), 255, 255);
      beginShape();
      for (int j = 0; j < animation.size(); ++j) {
        PVector v = animation.get(j).get(i).get(currentFrame);
        vertex(v.x, v.y);
      }
      endShape();
    }
    currentFrame--;
    if (currentFrame == 0) {
      status = GRID_DISPLAY;
    }
  }
}

public void mouseClicked() {
  if (status == GRID_DISPLAY) {
    status = ANIMATION_DISPLAY;
  } else if(status == IMG_DISPLAY){
    status = REVERSE_ANIMATION_DISPLAY;
  }
}
class Complex{
    float x, y ;

    Complex(float x_val, float y_val){
        x = x_val;
        y = y_val;
    }

    Complex(){
        x = 0;
        y = 0;
    }

    public void setPolar(float r, float theta){
        x = r * cos(theta);
        y = r * sin(theta);
    }

    public Complex add(Complex other){
        Complex tot = new Complex(x+other.x, y+other.y);
        return tot;
    }

    public Complex substract(Complex other){
        Complex tot = new Complex(x-other.x, y-other.y);
        return tot;
    }

    public Complex times(float num){
        return new Complex(x * num, y * num);
    }

    public Complex power(float num){
        float r = getR();
        float theta = getAngle();

        r = pow(r,num);
        theta = theta * num;

        Complex ans = new Complex();
        ans.setPolar(r,theta);
        return ans;
    }

    public Complex reciprocal(){
        Complex w = new Complex();
        if(getR() != 0){
            w.setPolar(1/getR(), -getAngle());
        }
        return w;
    }

    public Complex timesI(){
        return new Complex(y,x);
    }

    public void printCartesian(){
        println(x,"+",y,"i");
    }

    public float getX(){
        return x;
    }
    public float getY(){
        return y;
    }
    public float getR(){
        return (sqrt(x*x+y*y));
    }
    public float getAngle(){
        return atan2(y,x);
    }
}
public ArrayList<ArrayList<PVector>> mapping(ArrayList<ArrayList<PVector>> points){
    ArrayList<ArrayList<PVector>> image = new ArrayList<ArrayList<PVector>>();
    for (int i = 0; i < points.size(); ++i) {
        ArrayList<PVector> col = points.get(i);
        ArrayList<PVector> wCol = new ArrayList<PVector>();
        for (int j = 0; j < col.size(); ++j) {
            PVector vec = col.get(j);
            Complex z = new Complex(vec.x/divideConst, vec.y/divideConst);
            Complex w = f(z);
            wCol.add(new PVector(w.getX()*divideConst, w.getY()*divideConst));
        }
        image.add(wCol);
    }
    return image;
}

public Complex f(Complex z){
    //Squared
    //Complex w = z.power(2);

    //Complex w = z.add(new Complex(1,0)).reciprocal().power(2);
    //Complex w = z.power(2).reciprocal().add(z.times(5));
    //Complex w = z.times(2);

    //Recipocal
    Complex w = z.reciprocal();

    //Multipy by i
    //Complex w = z.timesI();

    //Complex w = new Complex();
    //w.setPolar(pow(z.getR(),2),z.getAngle());
    //w.setPolar(1/z.getR(),z.getAngle());
    //w.printCartesian();
    return w;
}

public ArrayList<ArrayList<ArrayList<PVector>>> generateFrame(ArrayList<ArrayList<PVector>> start, ArrayList<ArrayList<PVector>> end){
    ArrayList<ArrayList<ArrayList<PVector>>> animation = new ArrayList<ArrayList<ArrayList<PVector>>>();
    for (int i = 0; i < start.size(); ++i) {
        ArrayList<PVector> startcolcol = start.get(i);
        ArrayList<PVector> endcolcol = end.get(i);
        ArrayList<ArrayList<PVector>> resultCol = new ArrayList<ArrayList<PVector>>();

        for (int j = 0; j < startcolcol.size(); ++j) {
            PVector first = startcolcol.get(j);
            PVector last = endcolcol.get(j);
            ArrayList<PVector> locations = new ArrayList<PVector>();
            for (int k = 0; k < no_of_Frames; ++k) {
                float cordX ,cordY;
                if (first.x == last.x) {
                    cordX = first.x;
                } else {
                    cordX = map(PApplet.parseFloat(k),0,no_of_Frames,first.x,last.x);
                }
                if (first.y == last.y){
                    cordY = first.y;
                } else {
                    cordY = map(PApplet.parseFloat(k),0,no_of_Frames,first.y,last.y);
                }
                locations.add(new PVector(cordX,cordY));
            }
            resultCol.add(locations);
        }
        animation.add(resultCol);
    }
    return animation;
}


  public void settings() { size(600, 600, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "normal_functions_using_lines" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
